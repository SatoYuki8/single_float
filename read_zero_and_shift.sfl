circuit read_zero_and_shift{
    input frac<26>;
    input exp<8>;
    output shifted_frac<26>;
    output sub_exp<8>;
    instrin do;

    sel_v tmp<8>;   /* shift amount */
    reg_wr z;

    instruct do par{
	alt{
	    (frac<25> == 0b1): tmp = 0b00000000;
	    (frac == 0b00000000000000000000000000): par{
		z := 0b1;
		tmp = 0b00000000;
		}
	    (frac<25:24> == 0b01): tmp = 0b00000001;	    
	    (frac<25:23> == 0b001): tmp = 0b00000010;	    
	    (frac<25:22> == 0b0001): tmp = 0b00000011;	    
	    (frac<25:21> == 0b00001): tmp = 0b00000100;	    
	    (frac<25:20> == 0b000001): tmp = 0b00000101;
	    (frac<25:19> == 0b0000001): tmp = 0b00000110;
	    (frac<25:18> == 0b00000001): tmp = 0b00000111;
	    (frac<25:17> == 0b000000001): tmp = 0b00001000;
	    (frac<25:16> == 0b0000000001): tmp = 0b00001001;
	    (frac<25:15> == 0b00000000001): tmp = 0b00001010;
	    (frac<25:14> == 0b000000000001): tmp = 0b00001011;
	    (frac<25:13> == 0b0000000000001): tmp = 0b00001100;
	    (frac<25:12> == 0b00000000000001): tmp = 0b00001101;
	    (frac<25:11> == 0b000000000000001): tmp = 0b00001110;
	    (frac<25:10> == 0b0000000000000001): tmp = 0b00001111;
	    (frac<25:9> == 0b00000000000000001): tmp = 0b00010000;
	    (frac<25:8> == 0b000000000000000001): tmp = 0b00010001;
	    (frac<25:7> == 0b0000000000000000001): tmp = 0b00010010;
	    (frac<25:6> == 0b00000000000000000001): tmp = 0b00010011;
	    (frac<25:5> == 0b000000000000000000001): tmp = 0b00010100;
	    (frac<25:4> == 0b0000000000000000000001): tmp = 0b00010101;
	    (frac<25:3> == 0b00000000000000000000001): tmp = 0b00010110;
	    (frac<25:2> == 0b000000000000000000000001): tmp = 0b00010111;
	    (frac<25:1> == 0b0000000000000000000000001): tmp = 0b00011000;
	    (frac == 0b00000000000000000000000001): tmp = 0b00011001;
	}

	alt{
	    (z == 0b1): par{
		shifted_frac = 0b00000000000000000000000000;
		sub_exp = 0b00000000;
	    }
	    else: par{
		shifted_frac = frac << tmp;
		sub_exp = exp + (^tmp + 0b00000001);
	    }
	}
    }
}
